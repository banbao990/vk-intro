#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : require

#include "shared_with_shaders.h"


layout(set = SWS_ENVS_SET, binding = 0) uniform sampler2D EnvTexture;

layout(set = SWS_SCENE_AS_SET,          binding = SWS_SCENE_AS_BINDING)                 uniform accelerationStructureEXT Scene;
layout(set = SWS_RESULT_IMAGE_SET,      binding = SWS_RESULT_IMAGE_BINDING, rgba8)      uniform image2D ResultImage;
layout(set = SWS_ACCUMULATED_IMAGE_SET, binding = SWS_ACCUMULATED_IMAGE_BINDING, rgba8) uniform image2D AccumulatedImage;

layout(set = SWS_CAMDATA_SET,      binding = SWS_CAMDATA_BINDING, std140)     uniform AppData {
    UniformParams Params;
};

layout(location = SWS_LOC_PRIMARY_RAY) rayPayloadEXT RayPayload PrimaryRay;
layout(location = SWS_LOC_SHADOW_RAY)  rayPayloadEXT ShadowRayPayload ShadowRay;

const float kBunnyRefractionIndex = 1.0f / 1.31f; // ice

vec3 CalcRayDir(vec2 screenUV, float aspect) {
    vec3 u = Params.camSide.xyz;
    vec3 v = Params.camUp.xyz;

    const float planeWidth = tan(Params.camNearFarFov.z * 0.5f);

    u *= (planeWidth * aspect);
    v *= planeWidth;

    const vec3 rayDir = normalize(Params.camDir.xyz + (u * screenUV.x) - (v * screenUV.y));
    return rayDir;
}

const float MY_PI = 3.1415926535897932384626433832795;
const float MY_INV_PI  = 1.0 / MY_PI;

vec2 DirToLatLong(vec3 dir) {
    float phi = atan(dir.x, dir.z);
    float theta = acos(dir.y);

    return vec2((MY_PI + phi) * (0.5 / MY_PI), theta * MY_INV_PI);
}

// randam sampler start
const float RAND_2_1 = 1.0f / 4294967296.0f;

float rand_lcg(inout uint rng_state) {
    // LCG values from Numerical Recipes
    rng_state = 1664525 * rng_state + 1013904223;
    return rng_state * RAND_2_1;
}

float rand_xorshift(inout uint rng_state) {
    // Xorshift algorithm from George Marsaglia's paper
    rng_state ^= (rng_state << 13);
    rng_state ^= (rng_state >> 17);
    rng_state ^= (rng_state << 5);
    return rng_state * RAND_2_1;
}

float rand_whash(inout uint seed) {
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed * RAND_2_1;
}

vec3 random_cosine_direction(inout uint wseed) {
    float r1 = rand_whash(wseed);
    float r2 = rand_whash(wseed);
    float z = sqrt(1 - r2);

    float phi = MY_PI * 2 * r1;
    float x = cos(phi) * sqrt(r2);
    float y = sin(phi) * sqrt(r2);
    return vec3(x, y, z);
}

// random sampler end


void main() {
    const vec2 curPixel = vec2(gl_LaunchIDEXT.xy);
    const vec2 bottomRight = vec2(gl_LaunchSizeEXT.xy - 1);

    const vec2 uv = (curPixel / bottomRight) * 2.0f - 1.0f;

    const float aspect = float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);

    vec3 origin = Params.camPos.xyz;
    vec3 direction = CalcRayDir(uv, aspect);

    const uint rayFlags = gl_RayFlagsOpaqueEXT;
    const uint shadowRayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT;
    const uint cullMask = 0xFF;
    const uint stbRecordStride = 1;

    const float tmin = 0.0f;
    const float tmax = Params.camNearFarFov.y;

    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);
    float throughout_pdf = 1.0f;
    vec3 finalColor = vec3(0.0f, 0.0f, 0.0f);

    uint wseed = gl_LaunchIDEXT.x * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.y + Params.random_seed;

    for (int i = 0; i < SWS_MAX_RECURSION; ++i) {
        traceRayEXT(Scene,
                    rayFlags,
                    cullMask,
                    SWS_PRIMARY_HIT_SHADERS_IDX,
                    stbRecordStride,
                    SWS_PRIMARY_MISS_SHADERS_IDX,
                    origin,
                    tmin,
                    direction,
                    tmax,
                    SWS_LOC_PRIMARY_RAY);

        const vec3 hitColor = PrimaryRay.colorAndDist.rgb;
        const float hitDistance = PrimaryRay.colorAndDist.w;

        // if hit background - quit
        if (hitDistance < 0.0f) {
            finalColor += throughput * hitColor;
            break;
        } else {
            const vec3 hitNormal = PrimaryRay.normalAndObjId.xyz;
            const float objectId = PrimaryRay.normalAndObjId.w;

            const vec3 hitPos = origin + direction * hitDistance;

            if (objectId == OBJECT_ID_TEAPOT) {
                // our teapot is mirror, so reflect and continue

                origin = hitPos + hitNormal * 0.001f;
                direction = reflect(direction, hitNormal);
            } else if (objectId == OBJECT_ID_BUNNY) {
                // our bunny is made of ice, so refract and continue

                const float NdotD = dot(hitNormal, direction);

                vec3 refrNormal = hitNormal;
                float refrEta;

                if(NdotD > 0.0f) {
                    refrNormal = -hitNormal;
                    refrEta = 1.0f / kBunnyRefractionIndex;
                } else {
                    refrNormal = hitNormal;
                    refrEta = kBunnyRefractionIndex;
                }

                origin = hitPos + direction * 0.001f;
                direction = refract(direction, refrNormal, refrEta);
            } else if (objectId == OBJECT_ID_LIGHT) {
                // hit light
                finalColor += hitColor * throughput / throughout_pdf;
            } else {
                
                // we hit diffuse primitive - simple lambertian
                const vec3 toLight = normalize(Params.sunPosAndAmbient.xyz);
                const vec3 shadowRayOrigin = hitPos + hitNormal * 0.001f;

                const vec3 localDirection = random_cosine_direction(wseed);
                const float pdf = dot(localDirection, vec3(0.0f, 0.0f, 1.0f)) / MY_PI;

                // dirty implement
                mat3 local2world;
                const vec3 normal01 = normalize(hitNormal);
                const vec3 a = (abs(normal01[0]) > 0.9f) ? vec3(0.0f, 1.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);
                local2world[2] = normal01;
                local2world[1] = normalize(cross(normal01, a));
                local2world[0] = cross(normal01, local2world[1]);
                // dirty implment

                origin = hitPos + hitNormal * 0.001f;
                direction = local2world * localDirection;
                throughput *= pdf * hitColor;
                throughout_pdf *= pdf;
            }
        }
    }

    // finalColor = textureLod(EnvTexture, DirToLatLong(direction), 0).rgb;
    uint spp = Params.accumulate_spp;
    if(spp != 1) {
        finalColor = (finalColor + (spp-1) * imageLoad(AccumulatedImage, ivec2(gl_LaunchIDEXT.xy)).rgb) / spp;
    }
    
    imageStore(AccumulatedImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 1.0f));
    finalColor = LinearToSrgb(finalColor);
    imageStore(ResultImage, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 1.0f));
}
